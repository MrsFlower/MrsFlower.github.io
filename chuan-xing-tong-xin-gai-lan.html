<!DOCTYPE html>
<html lang="chinese (simplified)">
<head>

        <title>串行通信概览</title>
        <meta charset="utf-8" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="./theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="./theme/style.css" />
        <link rel="stylesheet" type="text/css" href="./theme/pygment.css" />

        <script src="./theme/js/libs/modernizr-2.6.2.min.js"></script>




</head>

<body id="index" class="home">


    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="./">lily`s blog <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>
             
              <ul class="columns">
                <li><a href="./">Home</a></li>


              </ul>
            </div>

<section id="content" class="body">

   <div class="row">
        <div class="eleven columns">


            <header>
              <h2 class="entry-title">
                <a href="./chuan-xing-tong-xin-gai-lan.html" rel="bookmark"
                   title="Permalink to 串行通信概览">串行通信概览</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2019-04-08T19:50:00+08:00">
                周一 08 四月 2019
              </abbr>
              <address class="vcard author">By 
                <a class="url fn" href="./author/ni.html"> NI</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <h1>Task</h1>
<p>转载自NI官网，链接：http://digital.ni.com/public.nsf/allkb/47B89C1DD3026CEC862579760020BB34
1.       简介
串行接口简称串口，也称串行通信接口（通常指COM接口），是采用串行通信方式的扩展接口。串口几乎为所有计算机的装置通讯协议标准。请别与通用串行总线 (Universal serial bus，USB) 产生混肴。
串行接口（Serial Interface）是指数据一位位地顺序传送，其特点是通信线路简单，只要一对传输线就可以实现双向通信，并可以利用电话线，从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。串行通讯的特点是：数据位传送，传按位顺序进行，最少只需一根传输线即可完成；成本低但传送速度慢。串行通讯的距离可以从几米到几千米；根据信息的传送方向，串行通讯可以进一步分为单工、半双工和全双工三种。 </p>
<p>串口的出现是在1980年前后，数据传输率是115kbps～230kbps。串口出现的初期是为了实现连接计算机外设的目的，初期串口一般用来连接鼠标和外置Modem以及老式摄像头和写字板等设备。串口也可以应用于由于两台计算机（或设备）之间的互联及数据传输。由于串口（COM）不支持热插拔及传输速率较低目前部分新主板和大部分便携电脑已开始取消该接口，目前串口多用于工控和测量设备以及部分通信设备中。 </p>
<p>串口形容一下就是一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。但是并不是说并口快，由于8位通道之间的互相干扰，传输时速度就受到了限制。而且当传输出错时，要同时重新传8个位的数据。串口没有干扰，传输出错后重发一位就可以了，所以要比并口快。串口硬盘就是这样被人们重视的。 </p>
<ol>
<li>分类及比较</li>
</ol>
<p>串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS-485等。RS-232-C、RS-422与RS-485标准只对接口的电气特性做出规定，不涉及接插件、电缆或协议。</p>
<p>RS-232-C</p>
<p>也称标准串口，最常用的一种串行通讯接口。它是在1970年由美国电子工业协会（EIA）联合贝尔系统、调制解调器厂家及计算机终端生产厂家共同制定的用于串行通讯的标准。它的全名是“数据终端设备（DTE）和数据通讯设备（DCE）之间串行二进制数据交换接口技术标准”。传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。 </p>
<p>RS-232采取不平衡传输方式，即所谓单端通讯。由于其发送电平与接收电平的差仅为2V至3V左右，所以其共模抑制能力差，再加上双绞线上的分布电容，其传送距离最大为约15米，最高速率为20kb/s。RS-232是为点对点（即只用一对收、发设备）通讯而设计的，其驱动器负载为3~7kΩ。所以RS-232适合本地设备之间的通信。
图1 RS-232 DB-9引脚图
RS-422
标准全称是“平衡电压数字接口电路的电气特性”，它定义了接口电路的特性。典型的RS-422是四线接口，实际上还有一根信号地线，共5根线。由于接收器采用高输入阻抗和发送驱动器比RS232更强的驱动能力，故允许在相同传输线上连接多个接收节点，最多可接10个节点。即一个主设备（Master），其余为从设备（Slave），从设备之间不能通信，所以RS-422支持点对多的双向通信。接收器输入阻抗为4k，故发端最大负载能力是10×4k+100Ω（终接电阻）。RS-422四线接口由于采用单独的发送和接收通道，因此不必控制数据方向，各装置之间任何必须的信号交换均可以按软件方式（XON/XOFF握手）或硬件方式（一对单独的双绞线）实现。 
RS-422的最大传输距离为1219米，最大传输速率为10Mb/s。其平衡双绞线的长度与传输速率成反比，在100kb/s速率以下，才可能达到最大传输距离。只有在很短的距离下才能获得最高速率传输。一般100米长的双绞线上所能获得的最大传输速率仅为1Mb/s。 
RS-485
是从RS-422基础上发展而来的，所以RS-485许多电气规定与RS-422相仿。如都采用平衡传输方式、都需要在传输线上接终接电阻等。RS-485可以采用二线与四线方式（485不同的收发模式可参考链接中KnowledgeBase 17M6L0TI），二线制可实现真正的多点双向通信，而采用四线连接时，与RS-422一样只能实现点对多的通信，即只能有一个主（Master）设备，其余为从设备，但它比RS-422有改进，无论四线还是二线连接方式总线上可多接到32个设备。（2线和4线模式下的引脚连接方式可参考KnowledgeBase 3DQBQ0OY）。
RS-485与RS-422的不同还在于其共模输出电压是不同的，RS-485是-7V至+12V之间，而RS-422在-7V至+7V之间，RS-485接收器最小输入阻抗为12kΩ、RS-422是4kΩ；由于RS-485满足所有RS-422的规范，所以RS-485的驱动器可以用在RS-422网络中应用。 
RS-485与RS-422一样，其最大传输距离约为1219米，最大传输速率为10Mb/s。平衡双绞线的长度与传输速率成反比，在100kb/s速率以下，才可能使用规定最长的电缆长度。只有在很短的距离下才能获得最高速率传输。一般100米长双绞线最大传输速率仅为1Mb/s </p>
<p>图2 RS-422/485 DB-9引脚图</p>
<p>RS-232、RS-422和RS-485的简单区别</p>
<p>标准
RS-232
RS-422
RS-485
工作方式
单端
差分
差分
节点数
1发1收
1发10收
1发32收
最大传输电缆长度
50英尺
4000英尺
4000英尺
最大传输速率
20Kb/s
10Mb/s
10Mb/s
表1   RS-232、RS-422和RS-485的区别</p>
<p>关于RS-422和RS-485的接线方式
RS-422可支持40个节点，RS-485支持128个节点，因此可以多节点构成网络。网络拓扑一般采用终端匹配的总线型结构，不支持环形或星形网络。在构建网络时，应注意如下几点：</p>
<p>1．采用一条双绞线电缆作总线，将各个节点串接起来，从总线到每个节点的引出线长度应尽量短，以便使引出线中的反射信号对总线信号的影响最低。图3所示为实际应用中常见的一些错误连接方式（a，b，c）和正确的连接方式（d，e，f）。a，b，c这三种网络连接尽管不正确，在短距离、低速率仍可能正常工作，但随着通信距离的延长或通信速率的提高，其不良影响会越来越严重，主要原因是信号在各支路末端反射后与原信号叠加，会造成信号质量下降。 </p>
<p>2．应注意总线特性阻抗的连续性，在阻抗不连续点就会发生信号的反射。下列几种情况易产生这种不连续性：总线的不同区段采用了不同电缆，或某一段总线上有过多收发器紧靠在一起安装，再者是过长的分支线引出到总线。</p>
<p>总之，应该提供一条单一、连续的信号通道作为总线。</p>
<p>图3   接线方式示意图</p>
<ol>
<li>串口通信
串口通信（Serial Communications）的概念非常简单，串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总长不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。典型地，串口用于ASCII码字符的传输。通信使用3根线完成：地线、发送、接收。由于串口通信是异步的，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但不是必须的。串口通信最重要的参数是波特率、数据位、停止位和奇偶校验。对于两个进行通信的端口，这些参数必须匹配： </li>
</ol>
<p>a.    波特率：这是一个衡量通信速度的参数。它表示每秒钟传送的bit的个数。例如300波特表示每秒钟发送300个bit。当我们提到时钟周期时，我们就是指波特率例如如果协议需要4800波特率，那么时钟是4800Hz。这意味着串口通信在数据线上的采样率为4800Hz。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。 </p>
<p>b.   数据位：这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。 </p>
<p>c.   停止位：用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。 </p>
<p>d.   奇偶校验位：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位为1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步。</p>
<ol>
<li>握手
3 种最常见的 EIA-232 握手形式，即为软件握手、硬件握手，与 Xmodem。</li>
</ol>
<p>软件握手</p>
<p>此方式是将数据字节作为控制字符 (Control character)，近似于 GPIB 使用命令字符串 (Command string) 的方式。由于控制字符可透过传输线路，如正常数据般进行传输，因此亦可整合 Tx、Rx，与接地而成简易的 3 线式集合。透过 SetXMode 函式，即可启用或停用 2 个控制字符：XON 与 XOFF。数据接收器将传送这些字符，以于通讯期间暂停传送器。</p>
<p>此方式的最大缺点，也是最重要的概念：数据值将不再使用 Decimal 17 与 19。由于这些数值为无字符 (Noncharacter) 数值，因此往往不会影响 ASCII 的传输作业；然而，若以二进制法传输数据，则极可能将这些数值作为数据进行传输，导致传输作业发生错误。</p>
<p>硬件握手</p>
<p>此方式将使用实际的硬件线路。如同 Tx 与 Rx 线路一般，RTS/CTS 与 DTR/DSR 线路可搭配使用。若其中 1 个线路为输出，则另 1 个线路即为输入。</p>
<p>第一种线路集为 RTS (Request to Send) 与 CTS (Clear to Send)。当接收器可接收资料时，则将插入 (Assert) RTS 线路，表示接收器已可接收资料。接着将由 CTS 输入线路的传送器读取此讯息，表示已可传送数据。</p>
<p>第二种线路集为 DTR (Data Terminal Ready) 与 DSR (Data Set Ready)。由于此种线路可让串行端口与调制解调器之间通讯现有状态，因此主要用于调制解调器的通讯作业。举例来说，当调制解调器可为计算机传送数据时，将先中断 DTR 线路，代表目前是透过电话线进行链接作业。接着 DSR 线路将读取该讯息，计算机则开始传送数据。在一般情况下，DTR/DSR 线路是用以表示系统可进行通讯作业，而 RTS/CTS 线路则用于独立的数据框架。</p>
<p>在 LabWindows/CVI 中，SetCTSMode 函式将启用或停用硬件握手。若已启用 CTS 模式，则 LabWindows/CVI 将依循下列规则：</p>
<p>计算机传送数据时：
EIA-232 函式库必须于传送数据之前，侦测该 CTS 线路为高 (High) 状态。</p>
<p>计算机接收数据时：
若通讯端口为开启状态，且输入队列具有容纳数据的空间，则函式库将引发 (Raise) RTS 与 DTR。
若通讯端口输入队列已达 90%，则函式库将降低 RTS 并提升 DTR。
若通讯端口输入队列近乎空白，则函式库将引发 RTS 并保持 DTR 为高状态。
若通讯端口为关闭，则函式库将降低 RTS 与 DTR。</p>
<p>XModem 握手</p>
<p>虽然此种协议已普遍用于调制解调器通讯作业，若其他装置均可使用此种协议，仍可直接于装置之间使用 XModem 协议。在 LabWindows/CVI 中，使用者可选择是否隐藏实际的 XModem 建置。只要计算机透过 XModem 协议连接其他装置，即可使用 LabWindows/CVI 的 XModem 函式，以传送档案至其他地址 (Site)。该函式为 XModemConfig、XModemSend，与 XModemReceive。</p>
<p>根据下列参数使用协议：start_of_data、end_of_trans、neg_ack、ack、wait_delay、start_delay、max_tries，与 packet_size。传输数据的 2 边必须同时认可这些参数，而 XModem 则提供相关标准定义。然而，使用者可透过 LabWindows/CVI 中的 XModemConfig 函式修改这些参数，以符合任何需求。在接收器 (Receiver) 传送 neg_ack 字符之后，即可于 XModem 中使用这些参数。此字符将告诉传送器 (Sender) 已准备好接收资料。于每次传输尝试之间，接收器均将使用 start_delay 时间，直到满足 max_tries 或接收到传送器的 start_of_data。若满足 max_tries，则接收器将提醒使用者目前无法沟通传送器。若的确接收到传送器的 start_of_data，则接收器将读取后续的信息封包。此封包具有封包号码、可检查错误的封包补充码、packet_size 字节的实际数据封包，与用于更多错误检查的数据总和检查码 (Checksum)。在读取数据之后，接收器将呼叫 wait_delay，并于稍后传送认可字符 (Ack) 回传送器。若传送器未接受到 ack，则将重新传送 max_tries 数据封包，直到接收 ack 为止。若传送器一直未接收 ack，则将通知使用者传送档案失败。</p>
<p>由于传送器必须以 packet_size 字节的封包传送数据，因此若没有足够数据填满最后的封包，则传送器将使用 ASCII NULL (0) 字节填满数据封包。如此将使接收档案大于源文件。由于 XModem 传输作业的封包号码，极可能增加 XON/OFF 控制字符而造成通讯中断，因此 XModem 协议并不适合搭配使用 XON/XOFF。</p>
<ol>
<li>串口回环测试
串口的回环测试可以让我们用来检测串口是否能够正常工作。我们只需要进行简单的连线即可进行测试，无需去使用额外的第三方的硬件。</li>
</ol>
<p>对于简单的回环测试，我们需要将引脚中的数据发送端口和数据接收端口相连以便实现数据的收发。即在RS-232的回环测试中，我们需要将数据发送引脚TXD和数据接受引脚RXD相连，同样，对于工作在差分方式下的422/485的回环测试，我们需要分别将引脚TXD+和RXD+，TXD-和RXD-相连。如下图所示：</p>
<p>图4   RS-232  DB9和DB25的接线方式</p>
<p>图5   RS-422/485 DB9和DB25的接线方式</p>
<p>对于回环测试的实施，我们可以通过超级终端、MAX、LabVIEW等来完成。在超级终端和MAX中，我们进行简单的配置即可实现回环测试，如果通过LabVIEW来完成，可以使用LabVIEW自带的范例Basic Serial Write and Read.vi来进行。具体的测试方法参考链接: How to Do a Serial Loopback Test .</p>
<ol>
<li>串口测试常见的问题
许多问题是软件问题，而不是硬件问题。可使用使用LabVIEW自带的例子程序作为查找错误的起点。</li>
</ol>
<p>a.    端口参考：在LabVIEW中，端口从0开始编号。因此LabVIEW中端口0就是PC上的COM1。
· PC：0＝COM1，1＝COM2，等等。
· Mac：0＝Modem，1＝Printer，等等。
· Sun：0＝ttya，1＝ttyb，等等。</p>
<p>b.    程序中定时，挂起：许多次对端口的读操作中串口Read VI导致停止运行并且等待或者挂起。这常常发生在一个读操作并且指定读取一定数量的字节。串口Read VI读取制定数量的字节，如果在串口接收buffer中没有足够的字符，它会等待到串口收到更多的字节。如果没有更多的字节写到buffer中完成读取操作，程序就会不确定的挂起和等待。这可以通过使用Serial Read with Timeout VI（位于Help-&gt;Search Examples-&gt;Serial Communication）消除。另一种方法是使用Bytes At Serial Port VI检查端口，知道buffer中还有多少字节。把结果连接到read的输入，作为读取的字节数，这样可以保证读操作完成。请看LabVIEW的串口通信例子作为一个很好的学习串口的起点。</p>
<p>c.      程序中的定时，不完全传输：另一个常见问题是读操作完成，但是实际上没有完全收到预期的、完整的信息字符串。这也许会在你开始读但是写操作还没完成时发生。这种情况可以使用一个顺序结构或者使用数据流的依赖性解决。数据流的依赖可以通过在初始化写后连线到写操作（通常是error cluster）实现。</p>
<p>d.     仪器终止字符：当检验和设备通信时，串口通信非常方便，因为串口能够完全按程序中制定的输出。这意味着你必须知道和编写程序指定码序，包括停止字符，这样才能保证仪器正常工作。通常出现的问题是没有使用仪器所规定的停止字符，或者在指令字符串中写了多余的空格或者其他字符。在LabVIEW中最新的和设备通信的标准是虚拟仪器软件架构（VISA）。VISA是控制VXI、GPIB、RS-232和其他类型仪器的统一接口库。如果你有串口I/O通信的问题，VISA可以帮助你消除结束字符的错误，同时能使你的代码在将来具有可重用性和设备可互换性。</p>
<ol>
<li>串口设备在超级终端中工作，但不在LabVIEW或MAX下的VISA测试面板中工作</li>
</ol>
<p>串口设备可能在超级终端中工作但不在LabVIEW或MAX下的VISA测试面板中工作的原因有两个：终止符不同和字符传输速度不同。使用下面的方法来解决与这两个原因相关的问题。 </p>
<p>确保超级终端与LabVIEW中使用的终止符相匹配</p>
<p>一般情况下，超级终端在其发送的每条信息之后添加一组 \r\n，它对应于一个回车符后紧跟着一个换行符。 
在LabVIEW中您可以使用字符型输入和显示控件的 \代码显示 项来检查终止符是否一致。例如，您可以使用loopback测试方法（关于loopback测试说明请参见下面链接中的NI开发者园地指南）从超级终端发出一个字符串，然后在LabVIEW中读回。这会帮助您确定超级终端使用了什么终止符。然后，再次使用loopback测试，从LabVIEW中发出相同的字符串并在LabVIEW中读回。对比这些值即可决定两者的终止符是否相匹配。 </p>
<p>降低向设备发送命令字符串的速度。（如果串口设备较旧，并且/或者其没有硬件控制它，因此LabVIEW和/或MAX中的VISA测试面板以多快的速度向其发送串行数据就是一个问题）</p>
<p>一旦向超级终端中输入字符，超级终端就会将向串口写入这些字符。因此，当输入字符串时，超级终端将在字符串结束后发送6个独立的终止字符：首先是s, 然后是t, 最后是r等等。 
然而，LabVIEW则会获取所有字符串并一次性写入设备，且各字符间没有延迟。您可以使用一个for循环来进行测试，将该字符串输出到设备中且每次只输出一个字符，在循环内为每个字符间的输出设置一个短暂的延时。范例中的Basic Serial Write and Read_1 bit.vi就是一种实现方法。您可以使用LabVIEW 7.0或更新的版本打开该范例。 </p>
            </div><!-- /.entry-content -->


        </div><!-- /.eleven.columns -->

<div class="three columns">

  <h4>Pages</h4>

  <ul>

  




<nav class="widget">
  <h4>Social</h4>
  <ul class="blank">
    <li><a href="15866103056@163.com">邮箱</a></li>
    <li><a href="#">微博暂无</a></li>
  </ul>
</nav>

</div> </div><!-- /.row -->


</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">

                <li><div class="btn primary"><a href="https://github.com/MrsFlower" target="_blank">Github</a></div></li>




              </ul>
            </div>
          </div>
        </footer>

    </div>


  <script src="./theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="./theme/js/libs/gumby.min.js"></script>
  <script src="./theme/js/plugins.js"></script>
</body>
</html>